---
# This playbook contains common plays for setting up FS servers for osdcapps/Stein Vidar

- name: Create VG for FS data disk
  lvg: vg={{ fsdatavg }} state=present pvs={{ fsdatapv }}

- name: Create LVM LV for FS data disk
  lvol: vg={{ fsdatavg }} lv={{ fsdatalv }} size={{ fsdatalv_size }} pvs={{ fsdatapv }} state=present
  ignore_errors: yes

- name: register a variable for mount point
  set_fact: fslv={{ item.mount }} fstype={{ item.fstype }}
  with_items: "{{ ansible_mounts }}"
  when: item.mount == "/astro/" ~ ansible_hostname ~ "/" ~ fsdatalv

- debug: var=fslv
- debug: var=fstype

#- name: registering the mount point...
#  debug: msg="Variable to hold the mount"
#  with_item: ansible_mounts
#  register: 

###TODO don't try this if already mounted!
- name: Create a new XFS filesystem on the LV
  filesystem: fstype={{ filesystem }} dev=/dev/{{ fsdatavg }}/{{ fsdatalv }} force=no 
  with_items: ansible_mounts
  ignore_errors: yes
  when: fslv != "/astro/" ~ ansible_hostname ~ "/" ~ fsdatalv

- name: Create the mount point
  file: path=/astro/{{ ansible_hostname }}/{{ fsdatalv }} state=directory mode={{ mount_data_path_mode }} 
  when: fslv != "/astro/" ~ ansible_hostname ~ "/" ~ fsdatalv
 # when:  == "true"

- name: Mount the LV 
  mount: name=/astro/{{ ansible_hostname }}/{{ fsdatalv }} src=/dev/mapper/{{ fsdatavg }}-{{ fsdatalv }} fstype={{ filesystem }} state=mounted
  when: fslv != "/astro/" ~ ansible_hostname ~ "/" ~ fsdatalv

- name: Create a directory {{ user_sdc }} in /astro/{{ ansible_hostname }}/{{ fsdatalv  }}
  file: path=/astro/{{ ansible_hostname }}/{{ fsdatalv  }}/{{ user_sdc}} state=directory mode={{ mount_data_path_mode }} owner={{ user_osdcapps }} group={{ group_osdcapps }}

- name: Create a home directory for {{ user_osdcapps }} (osdcapps)
  file: path=/astro/{{ ansible_hostname }}/{{ fsdatalv  }}/{{ user_osdcapps }} state=directory mode={{ mount_data_path_mode }} owner={{ user_osdcapps }} group={{ group_osdcapps }}

- name: Set correct SELinux context for /astro/{{ ansible_hostname }}/{{ fsdatalv }}/{{ user_osdcapps }}
  shell: /usr/sbin/semanage fcontext -a -e /home /astro/{{ ansible_hostname }}/{{ fsdatalv }}/{{ user_osdcapps }} && /usr/sbin/restorecon -Rv /astro/{{ ansible_hostname }}/{{ fsdatalv }}/{{ user_osdcapps }}
  ignore_errors: yes

###TODO: find a way to check it if's got correct SELinux context already 
#- name: Set correct SELinux context (system_u:object_r:httpd_sys_content_t:s0) for /astro/{{ ansible_hostname }}/{{ fsdatalv }}/{{ user_sdc }}
#  shell: /usr/sbin/semanage fcontext -a -t httpd_sys_content_t  /astro/{{ ansible_hostname }}/{{ fsdatalv }}/{{ user_sdc }} && /usr/sbin/restorecon -Rv /astro/{{ ansible_hostname }}/{{ fsdatalv }}/{{ user_sdc }}
#  ignore_errors: yes

- name: Mount the disks in fstab
  shell: mount -a
  ignore_errors: yes

# NFS server setup
- name: Install NFS server config file
  template: src=/etc/ita/ansible/ita/oscdapps/roles/fs_osdcapps/templates/nfs_exportfs.j2 dest=/etc/exports force=yes
  when: ansible_hostname in sdc_fsservers

- name: Enable & start NFS service
  service: name=nfs-server.service state=started enabled=yes
  when: ansible_hostname in sdc_fsservers
  ignore_errors: yes

# Firewall 
- name: Install NFS  firewalld  service (port) definitions
  template: src={{ item }}.j2 dest=/etc/firewalld/services/{{ item }} force=yes
  with_items: "{{ nfs_fw_services }}"
  when: ansible_hostname in sdc_fsservers
  notify:
  - restart firewalld

- meta: flush_handlers

- name: Add NFS service and restart firewalld
  firewalld: service={{ item }} permanent=true state=enabled
  with_items:
  - nfs
  - mountd
  - lockd
  - rpc-bind
  notify:
  - restart firewalld

  


